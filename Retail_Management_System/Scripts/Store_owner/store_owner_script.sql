SET SERVEROUTPUT ON SIZE UNLIMITED
SET FEEDBACK ON

-- Procedure to drop table if it exists
DECLARE
  table_not_found EXCEPTION;
  insufficient_privilege EXCEPTION;
  PRAGMA EXCEPTION_INIT(table_not_found, -00955);
  PRAGMA EXCEPTION_INIT(insufficient_privilege, -01031);
BEGIN
-- Fetch the required tables and then loop over them and delete them.
  FOR t IN (SELECT table_name FROM user_tables WHERE table_name IN ('ADDRESS','CUSTOMER','PRODUCT','ORDERS','ITEM_ORDERS','EMPLOYEE','PURCHASES','VENDOR', 'PRODUCT_HISTORY') ) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE ' || t.table_name || ' CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('Dropped table ' || t.table_name);
  END LOOP;
EXCEPTION
  WHEN table_not_found THEN 
    raise_application_error(-2000, 'Exit');
  WHEN insufficient_privilege THEN
    DBMS_OUTPUT.PUT_LINE('Insufficient privileges to drop table ');
END;
/
CREATE TABLE Address (
    ADDRESS_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    HOUSE_NUMBER NUMBER,
    STREET VARCHAR2(20),
    CITY VARCHAR2(15),
    STATE VARCHAR2(20),
    COUNTRY VARCHAR2(20),
    POSTAL_CODE NUMBER
);

CREATE TABLE Customer (
    CUSTOMER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    FIRST_NAME VARCHAR2(30),
    LAST_NAME VARCHAR2(30),
    ADDRESS_ID NUMBER,
    PHONE_NUMBER VARCHAR2(15),
    EMAIL VARCHAR2(45)
);

CREATE TABLE Product (
    PRODUCT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    CATEGORY VARCHAR2(35),
    NAME VARCHAR2(35),
    REMAINING_UNITS NUMBER,
    SELLING_PRICE NUMBER
);

CREATE TABLE Orders (
    ORDER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    CUSTOMER_ID NUMBER,
    EMPLOYEE_ID NUMBER,
    ORDER_DATE TIMESTAMP -- Renamed 'DATE' to 'ORDER_DATE'
);

CREATE TABLE Item_Orders (
    ORDER_ID NUMBER,
    PRODUCT_ID NUMBER,
    SELLING_PRICE NUMBER,
    UNITS NUMBER
);

CREATE TABLE Employee (
    EMPLOYEE_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    FIRST_NAME VARCHAR2(30),
    LAST_NAME VARCHAR2(30),
    ADDRESS_ID NUMBER,
    EMAIL VARCHAR2(45),
    PHONE_NUMBER VARCHAR2(15),
    HIRING_DATE TIMESTAMP,
    ROLE VARCHAR2(15),
    WAGE NUMBER,
    LAST_DATE TIMESTAMP DEFAULT NULL
);

CREATE TABLE Purchases (
    TRANSACTION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    PURCHASE_DATE TIMESTAMP,
    VENDOR_ID NUMBER,
    PRODUCT_ID NUMBER,
    QUANTITY NUMBER,
    BUYING_PRICE NUMBER(10, 2)
);

CREATE TABLE Vendor (
    VENDOR_ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    NAME VARCHAR2(45),
    ADDRESS_ID NUMBER,
    PHONE_NUMBER VARCHAR2(45),
    EMAIL VARCHAR2(45),
    LAST_DATE TIMESTAMP DEFAULT NULL,
    PARTNERSHIP_DATE TIMESTAMP
);

CREATE TABLE product_history (
    product_history_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    product_id NUMBER NOT NULL,
    previous_price NUMBER,
    updated_price NUMBER,
    change_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE Address ADD PRIMARY KEY (ADDRESS_ID);
ALTER TABLE Customer ADD PRIMARY KEY (CUSTOMER_ID);
ALTER TABLE Product ADD PRIMARY KEY (PRODUCT_ID);
ALTER TABLE Orders ADD PRIMARY KEY (ORDER_ID);
ALTER TABLE Item_Orders ADD PRIMARY KEY (ORDER_ID, PRODUCT_ID);
ALTER TABLE Employee ADD PRIMARY KEY (EMPLOYEE_ID);
ALTER TABLE Purchases ADD PRIMARY KEY (TRANSACTION_ID);
ALTER TABLE Vendor ADD PRIMARY KEY (VENDOR_ID);
ALTER TABLE Product_history ADD PRIMARY KEY (PRODUCT_HISTORY_ID);

ALTER TABLE Customer ADD CONSTRAINT FK_Customer_Address FOREIGN KEY (ADDRESS_ID) REFERENCES Address(ADDRESS_ID);
ALTER TABLE Orders ADD CONSTRAINT FK_Orders_Customer FOREIGN KEY (CUSTOMER_ID) REFERENCES Customer(CUSTOMER_ID);
ALTER TABLE Orders ADD CONSTRAINT FK_Orders_Employee FOREIGN KEY (EMPLOYEE_ID) REFERENCES Employee(EMPLOYEE_ID);
ALTER TABLE Item_Orders ADD CONSTRAINT FK_ItemOrders_Orders FOREIGN KEY (ORDER_ID) REFERENCES Orders(ORDER_ID);
ALTER TABLE Item_Orders ADD CONSTRAINT FK_ItemOrders_Product FOREIGN KEY (PRODUCT_ID) REFERENCES Product(PRODUCT_ID);
ALTER TABLE Employee ADD CONSTRAINT FK_Employee_Address FOREIGN KEY (ADDRESS_ID) REFERENCES Address(ADDRESS_ID);
ALTER TABLE Purchases ADD CONSTRAINT FK_Purchases_Vendor FOREIGN KEY (VENDOR_ID) REFERENCES Vendor(VENDOR_ID);
ALTER TABLE Purchases ADD CONSTRAINT FK_Purchases_Product FOREIGN KEY (PRODUCT_ID) REFERENCES Product(PRODUCT_ID);
ALTER TABLE Vendor ADD CONSTRAINT FK_Vendor_Address FOREIGN KEY (ADDRESS_ID) REFERENCES Address(ADDRESS_ID);
ALTER TABLE Product_History ADD CONSTRAINT FK_Product_History_Product FOREIGN KEY (PRODUCT_ID) REFERENCES Product(PRODUCT_ID);

ALTER TABLE Customer ADD CONSTRAINT Unique_Customer_Email UNIQUE (EMAIL);

ALTER TABLE Employee ADD CONSTRAINT Unique_Employee_Email UNIQUE (EMAIL);

ALTER TABLE Vendor ADD CONSTRAINT Unique_Vendor_Email UNIQUE (EMAIL);

CREATE OR REPLACE TRIGGER after_product_add
AFTER INSERT ON Product
FOR EACH ROW
BEGIN
    INSERT INTO product_history (product_id, previous_price, updated_price, change_timestamp)
    VALUES (:NEW.product_id, :NEW.selling_price, :NEW.selling_price, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER after_product_update
AFTER UPDATE ON Product
FOR EACH ROW
WHEN (OLD.selling_price <> NEW.selling_price)
BEGIN
    INSERT INTO product_history (product_id, previous_price, updated_price, change_timestamp)
    VALUES (:NEW.product_id, :OLD.selling_price, :NEW.selling_price, SYSTIMESTAMP);
END;
/

-- View for Customer Order History
CREATE OR REPLACE VIEW Customer_Order_History AS
SELECT c.CUSTOMER_ID, INITCAP(c.FIRST_NAME) AS First_Name, INITCAP(c.LAST_NAME) as LAST_NAME, o.ORDER_ID, o.ORDER_DATE
FROM Customer c
JOIN Orders o ON c.CUSTOMER_ID = o.CUSTOMER_ID;


-- View for Vendor Order History
CREATE OR REPLACE VIEW Vendor_Order_History AS
SELECT v.VENDOR_ID, INITCAP(v.NAME) as VENDOR_NAME, p.TRANSACTION_ID, p.PURCHASE_DATE, p.QUANTITY
FROM Vendor v
JOIN Purchases p ON v.VENDOR_ID = p.VENDOR_ID;

-- View for Current Inventory
CREATE OR REPLACE VIEW Current_Inventory AS
SELECT p.PRODUCT_ID, INITCAP(p.NAME) as PRODUCT_NAME, p.REMAINING_UNITS
FROM Product p;

-- View for Low Stock
-- Assuming 'low stock' is defined as fewer than 10 units
CREATE OR REPLACE VIEW Low_Stock AS
SELECT 
    p.PRODUCT_ID, 
    INITCAP(p.NAME) AS PRODUCT_NAME, 
    p.REMAINING_UNITS
FROM 
    Product p
WHERE 
    (p.SELLING_PRICE < 15 AND p.REMAINING_UNITS < 50) OR
    (p.SELLING_PRICE BETWEEN 15 AND 100 AND p.REMAINING_UNITS < 20) OR
    (p.SELLING_PRICE > 100 AND p.REMAINING_UNITS < 10);

-- View for Product Sales
CREATE OR REPLACE VIEW Product_Sales AS
SELECT p.PRODUCT_ID, INITCAP(p.NAME) as PRODUCT_NAME, SUM(io.UNITS) AS TOTAL_UNITS_SOLD
FROM Product p
JOIN Item_Orders io ON p.PRODUCT_ID = io.PRODUCT_ID
GROUP BY p.PRODUCT_ID, p.NAME;

-- View for Weekly Sales
CREATE OR REPLACE VIEW Weekly_Sales AS
SELECT TO_CHAR(o.ORDER_DATE, 'IW') AS WEEK_NUMBER, SUM(io.UNITS) AS UNITS_SOLD
FROM Orders o
JOIN Item_Orders io ON o.ORDER_ID = io.ORDER_ID
WHERE o.ORDER_DATE BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2024-12-31', 'YYYY-MM-DD')
GROUP BY TO_CHAR(o.ORDER_DATE, 'IW');

-- View for Weekly Purchases
CREATE OR REPLACE VIEW Weekly_Purchases AS
SELECT TO_CHAR(p.PURCHASE_DATE, 'IW') AS WEEK_NUMBER, SUM(p.QUANTITY) AS QUANTITY_PURCHASED
FROM Purchases p
WHERE p.PURCHASE_DATE BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2024-12-31', 'YYYY-MM-DD')
GROUP BY TO_CHAR(p.PURCHASE_DATE, 'IW');

-- View for Employee Performance
CREATE OR REPLACE VIEW Employee_Performance AS
SELECT e.EMPLOYEE_ID, INITCAP(e.FIRST_NAME) as FIRST_NAME, INITCAP(e.LAST_NAME) as LAST_NAME, COUNT(o.ORDER_ID) AS TOTAL_ORDERS
FROM Employee e
JOIN Orders o ON e.EMPLOYEE_ID = o.EMPLOYEE_ID
GROUP BY e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME;


DECLARE
  user_exists EXCEPTION;
  role_exists EXCEPTION;
  PRAGMA EXCEPTION_INIT(user_exists, -01918); -- Oracle error code for "user not found"
  PRAGMA EXCEPTION_INIT(role_exists, -01924); -- Oracle error code for "role not granted or does not exist"

  PROCEDURE DropUserIfExists(user_name IN VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE 'DROP USER ' || user_name || ' CASCADE';
    DBMS_OUTPUT.PUT_LINE('User ' || user_name || ' dropped');
  EXCEPTION
    WHEN user_exists THEN
      DBMS_OUTPUT.PUT_LINE('User ' || user_name || ' does not exist, will be created');
  END;

  PROCEDURE DropRoleIfExists(role_name IN VARCHAR2) IS
  BEGIN
    EXECUTE IMMEDIATE 'DROP ROLE ' || role_name;
    DBMS_OUTPUT.PUT_LINE('Role ' || role_name || ' dropped');
  EXCEPTION
    WHEN role_exists THEN
      DBMS_OUTPUT.PUT_LINE('Role ' || role_name || ' does not exist, will be created');
  END;

BEGIN
  -- Dropping roles if they exist
  DropRoleIfExists('sales_rep_role');
  DropRoleIfExists('manager_role');
  DropRoleIfExists('inventory_clerk_role');
  DropRoleIfExists('accountant_role');

  -- Dropping users if they exist
  DropUserIfExists('sales_rep');
  DropUserIfExists('manager');
  DropUserIfExists('inventory_clerk');
  DropUserIfExists('accountant');
END;
/

-- Creating the Sales Representative user
CREATE USER sales_rep IDENTIFIED BY SalesRepPassword00;
-- Creating the sales_rep_role
CREATE ROLE sales_rep_role;

-- Granting privileges to the sales_rep_role
GRANT CREATE SESSION TO sales_rep_role;
GRANT SELECT ON Current_Inventory TO sales_rep_role;
GRANT SELECT ON Low_Stock TO sales_rep_role;
GRANT SELECT ON Customer_Order_History TO sales_rep_role;

-- Grant the role to the sales_rep user
GRANT sales_rep_role TO sales_rep;


-- Creating the Manager user
CREATE USER manager IDENTIFIED BY ManPassword00;
GRANT CREATE SESSION TO manager;

CREATE ROLE manager_role;

-- Granting privileges to manager_role
GRANT SELECT ON Current_Inventory TO manager_role;
GRANT SELECT ON Low_Stock TO manager_role;
GRANT SELECT ON Customer_Order_History TO manager_role;
GRANT SELECT ON Employee_Performance TO manager_role;
GRANT manager_role TO manager;

-- Creating the inventory_clerk_role
CREATE ROLE inventory_clerk_role;

-- Granting privileges to inventory_clerk_role
GRANT SELECT ON Current_Inventory TO inventory_clerk_role;
GRANT SELECT ON Low_Stock TO inventory_clerk_role;

-- Creating the inventory_clerk user and granting the role
CREATE USER inventory_clerk IDENTIFIED BY ClerkPassword00;
GRANT CREATE SESSION TO inventory_clerk;
GRANT inventory_clerk_role TO inventory_clerk;


-- Creating the accountant_role
CREATE ROLE accountant_role;

-- Granting privileges to accountant_role
GRANT SELECT ON Product_Sales TO accountant_role;
GRANT SELECT ON Low_Stock TO accountant_role;
GRANT SELECT ON Weekly_Sales TO accountant_role;
GRANT SELECT ON Weekly_Purchases TO accountant_role;

-- Creating the accountant user and granting the role
CREATE USER accountant IDENTIFIED BY AccountPassword00;
GRANT CREATE SESSION TO accountant;
GRANT accountant_role TO accountant;


CREATE OR REPLACE FUNCTION VALIDATE_EMAIL(p_email IN VARCHAR2) RETURN BOOLEAN IS
BEGIN
    -- Check if the email is non-empty and contains '@' and '.'
    IF p_email IS NOT NULL AND INSTR(lower(p_email), '@') > 1 AND INSTR(lower(p_email), '.', INSTR(lower(p_email), '@')) > INSTR(lower(p_email), '@') + 1 THEN
        RETURN TRUE; -- Valid Email
    ELSE
        RETURN FALSE; -- Invalid Email
    END IF;
END VALIDATE_EMAIL;
/

CREATE OR REPLACE FUNCTION EMAIL_EXISTS (
    p_email            IN EMPLOYEE.email%TYPE,
    p_table_name IN VARCHAR2
) RETURN NUMBER IS
    v_count NUMBER;
    v_email VARCHAR2(45);
    e_table_not_found EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_table_not_found, -00942); -- ORA-00942: table or view does not exist
    e_other_errors EXCEPTION;
BEGIN
    
    v_email := LOWER(p_email);
    EXECUTE IMMEDIATE 
        'SELECT COUNT(*) FROM ' || p_table_name || ' WHERE lower(EMAIL) = :1'
        INTO v_count
        USING v_email;

    RETURN v_count;
EXCEPTION
    WHEN e_table_not_found THEN
        DBMS_OUTPUT.PUT_LINE('Error: Table not found.');
        RETURN -1; -- Indicate specific error
    WHEN e_other_errors THEN
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
        RETURN -2; -- Indicate other errors
END EMAIL_EXISTS;
/

CREATE OR REPLACE FUNCTION VALIDATE_PHONE(p_phone IN VARCHAR2) RETURN BOOLEAN IS
  v_digit_count NUMBER;
BEGIN
  -- Remove non-digit characters and count the remaining digits
  SELECT
      REGEXP_COUNT(REGEXP_REPLACE(p_phone, '[^[:digit:]]'), '\d')
  INTO
      v_digit_count
  FROM
      DUAL;

  -- Check if the digit count is equal to 10
  IF v_digit_count = 10 THEN
      RETURN TRUE;
  ELSE
      RETURN FALSE;
  END IF;
END VALIDATE_PHONE;
/


-- Procedures

-- Procedure to add an employee record into the employee table
create or replace PROCEDURE ADD_EMPLOYEE_RECORD(
    pi_first_name       IN EMPLOYEE.first_name%TYPE,
    pi_last_name        IN EMPLOYEE.last_name%TYPE,
    pi_email            IN EMPLOYEE.email%TYPE,
    pi_phone            IN EMPLOYEE.phone_number%TYPE,
    pi_hiring_date      IN EMPLOYEE.hiring_date%TYPE,
    pi_role             IN EMPLOYEE.role%TYPE,
    pi_wage             IN EMPLOYEE.wage%TYPE,
    pi_house_number     IN ADDRESS.house_number%TYPE,
    pi_street           IN ADDRESS.street%TYPE,
    pi_city             IN ADDRESS.city%TYPE,
    pi_state            IN ADDRESS.state%TYPE,
    pi_country          IN ADDRESS.country%TYPE,
    pi_postal_code      IN ADDRESS.postal_code%TYPE
)
AS
    v_address_id ADDRESS.address_id%TYPE;
    v_email_count NUMBER;
    invalid_input EXCEPTION;
    email_invalid EXCEPTION;
    email_exists EXCEPTION;

BEGIN

    -- Validate input arguments
    IF pi_first_name IS NULL OR pi_last_name IS NULL OR pi_email IS NULL 
        OR pi_phone IS NULL OR pi_hiring_date IS NULL 
        OR pi_house_number IS NULL OR pi_street IS NULL OR pi_role IS NULL or pi_wage IS NULL
        OR pi_city IS NULL OR pi_state IS NULL 
        OR pi_country IS NULL OR pi_postal_code IS NULL THEN
        RAISE invalid_input;
    END IF;

    -- Validate email
    IF pi_email IS NOT NULL AND NOT VALIDATE_EMAIL(pi_email) THEN
        RAISE email_invalid;
    END IF;

    SELECT COUNT(*)
    INTO v_email_count
    FROM EMPLOYEE
    WHERE EMAIL = pi_email;

    IF v_email_count > 0 THEN
        RAISE email_exists;
    END IF;

    -- Insert into Address table
    INSERT INTO ADDRESS (HOUSE_NUMBER, STREET, CITY, STATE, COUNTRY, POSTAL_CODE)
    VALUES (pi_house_number, pi_street, pi_city, pi_state, pi_country, pi_postal_code)
    RETURNING ADDRESS_ID INTO v_address_id;

    DBMS_OUTPUT.PUT_LINE('Employee address added successfully');

    -- Insert into Employee table
    INSERT INTO EMPLOYEE (FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRING_DATE, ROLE, WAGE, ADDRESS_ID)
    VALUES (pi_first_name, pi_last_name, pi_email, pi_phone, pi_hiring_date, pi_role, pi_wage, v_address_id);

    COMMIT;

    DBMS_OUTPUT.PUT_LINE('Employee record added successfully');

EXCEPTION
    WHEN invalid_input THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Invalid input arguments');
    WHEN email_invalid THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Invalid email format');
    WHEN email_exists THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Email already exists');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);

END ADD_EMPLOYEE_RECORD;
/


GRANT EXECUTE ON ADD_EMPLOYEE_RECORD TO MANAGER_ROLE;


BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'Jane',
        pi_last_name     => 'Doe',
        pi_email         => 'jane@email.com',
        pi_phone         => '(857)555-6789',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Accountant',
        pi_wage          => 60000,
        pi_house_number  => 123,
        pi_street        => 'Main Street',
        pi_city          => 'Boston',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/

BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'James',
        pi_last_name     => 'Carter',
        pi_email         => 'carter@email.com',
        pi_phone         => '(857)544-3789',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Sales Rep',
        pi_wage          => 50000,
        pi_house_number  => 12,
        pi_street        => 'Stowe Street',
        pi_city          => 'Boston',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 13245
    );
END;
/

BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'Charles',
        pi_last_name     => 'Miller',
        pi_email         => 'miller@email.com',
        pi_phone         => '(857)544-4769',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Inventory Clerk',
        pi_wage          => 35000,
        pi_house_number  => 18,
        pi_street        => 'Adams Street',
        pi_city          => 'Boston',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 13245
    );
END;
/

BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'Rebecca',
        pi_last_name     => 'Jones',
        pi_email         => 'jonesrebecca@email.com',
        pi_phone         => '(857)344-4659',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Inventory Clerk',
        pi_wage          => 35000,
        pi_house_number  => 22,
        pi_street        => 'JK Street',
        pi_city          => 'Boston',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 13245
    );
END;
/

BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'Marie',
        pi_last_name     => 'Thomas',
        pi_email         => 'thomas@email.com',
        pi_phone         => '(855)364-6769',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Sales rep',
        pi_wage          => 66000,
        pi_house_number  => 145,
        pi_street        => 'Harlem Street',
        pi_city          => 'Cambridge',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 25245
    );
END;
/

BEGIN
    ADD_EMPLOYEE_RECORD(
        pi_first_name    => 'Millie',
        pi_last_name     => 'Bobby',
        pi_email         => 'bobby@email.com',
        pi_phone         => '(855)364-6769',
        pi_hiring_date   => SYSTIMESTAMP,
        pi_role          => 'Sales rep',
        pi_wage          => 66000,
        pi_house_number  => 145,
        pi_street        => 'Harlem Street',
        pi_city          => 'Cambridge',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 25245
    );
END;
/

CREATE OR REPLACE PROCEDURE ADD_VENDOR_RECORD(
    pi_name             IN VENDOR.NAME%TYPE,
    pi_email            IN VENDOR.EMAIL%TYPE,
    pi_phone            IN VENDOR.PHONE_NUMBER%TYPE,
    pi_house_number     IN ADDRESS.HOUSE_NUMBER%TYPE,
    pi_street           IN ADDRESS.STREET%TYPE,
    pi_city             IN ADDRESS.CITY%TYPE,
    pi_state            IN ADDRESS.STATE%TYPE,
    pi_country          IN ADDRESS.COUNTRY%TYPE,
    pi_postal_code      IN ADDRESS.POSTAL_CODE%TYPE
)
AS
    vendor_address_id ADDRESS.ADDRESS_ID%TYPE;
    v_vendor_count INTEGER;
    vendor_exists EXCEPTION;
    invalid_input EXCEPTION;
BEGIN
    IF pi_name IS NULL OR pi_email IS NULL OR pi_phone IS NULL
        OR pi_house_number IS NULL OR pi_street IS NULL
        OR pi_city IS NULL OR pi_state IS NULL
        OR pi_country IS NULL OR pi_postal_code IS NULL THEN
        RAISE invalid_input;
    END IF;

    SELECT COUNT(*) INTO v_vendor_count FROM VENDOR WHERE EMAIL = pi_email;
    IF v_vendor_count > 0 THEN
        RAISE vendor_exists;
    END IF;

    -- Insert into Address table
    INSERT INTO ADDRESS (HOUSE_NUMBER, STREET, CITY, STATE, COUNTRY, POSTAL_CODE)
    VALUES (pi_house_number, pi_street, pi_city, pi_state, pi_country, pi_postal_code)
    RETURNING ADDRESS_ID INTO vendor_address_id;
    DBMS_OUTPUT.PUT_LINE('Vendor address added successfully');
    -- Insert into Vendor table
    INSERT INTO VENDOR (NAME, EMAIL, PHONE_NUMBER, ADDRESS_ID, PARTNERSHIP_DATE)
    VALUES (pi_name, pi_email, pi_phone, vendor_address_id, SYSTIMESTAMP); -- Corrected to use pi_name instead of name
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Vendor record added successfully');
EXCEPTION
    WHEN invalid_input THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Invalid input arguments');
    WHEN vendor_exists THEN
        DBMS_OUTPUT.PUT_LINE('Vendor record already exists');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error has occurred during procedure execution');
    
END ADD_VENDOR_RECORD;
/
  
GRANT EXECUTE ON ADD_VENDOR_RECORD TO MANAGER_ROLE;

BEGIN
    ADD_VENDOR_RECORD(
        pi_name     => 'vendor A',
        pi_email         => 'vendor.a@example.com',
        pi_phone         => '1234567890',
        pi_house_number  => 123,
        pi_street        => 'Main Street',
        pi_city          => 'Springfield',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/
BEGIN
    ADD_VENDOR_RECORD(
        pi_name     => 'vendor B',
        pi_email         => 'vendor.b@example.com',
        pi_phone         => '1234567891',
        pi_house_number  => 234,
        pi_street        => 'Third St',
        pi_city          => 'Elder st',
        pi_state         => 'California',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/
BEGIN
    ADD_VENDOR_RECORD(
        pi_name     => 'vendor C',
        pi_email         => 'vendor.c@example.com',
        pi_phone         => '1234567892',
        pi_house_number  => 345,
        pi_street        => 'Fourth St',
        pi_city          => 'East cottage st',
        pi_state         => 'Nebraska',
        pi_country       => 'United States',
        pi_postal_code   => 02122
    );
END;
/
BEGIN
    ADD_VENDOR_RECORD(
        pi_name     => 'vendor D',
        pi_email         => 'vendor.d@example.com',
        pi_phone         => '1234567893',
        pi_house_number  => 456,
        pi_street        => 'Main Street',
        pi_city          => 'Anytown',
        pi_state         => 'State',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/
BEGIN
    ADD_VENDOR_RECORD(
        pi_name     => 'vendor E',
        pi_email         => 'vendor.e@example.com',
        pi_phone         => '1234567894',
        pi_house_number  => 567,
        pi_street        => 'Fifth St',
        pi_city          => 'Mass avenue',
        pi_state         => 'Tenesse',
        pi_country       => 'United States',
        pi_postal_code   => 20133
    );
END;
/

CREATE OR REPLACE PROCEDURE ADD_CUSTOMER_RECORD(
    pi_first_name     IN CUSTOMER.FIRST_NAME%TYPE,
    pi_last_name      IN CUSTOMER.LAST_NAME%TYPE,
    pi_phone          IN CUSTOMER.PHONE_NUMBER%TYPE,
    pi_email          IN CUSTOMER.EMAIL%TYPE,
    pi_house_number   IN ADDRESS.HOUSE_NUMBER%TYPE,
    pi_street         IN ADDRESS.STREET%TYPE,
    pi_city           IN ADDRESS.CITY%TYPE,
    pi_state          IN ADDRESS.STATE%TYPE,
    pi_country        IN ADDRESS.COUNTRY%TYPE,
    pi_postal_code    IN ADDRESS.POSTAL_CODE%TYPE
)
AS
    v_address_id ADDRESS.ADDRESS_ID%TYPE;
    v_customer_count INTEGER;
    invalid_input EXCEPTION;
    customer_exists EXCEPTION;
BEGIN
    -- Validate input arguments
    IF pi_first_name IS NULL OR pi_last_name IS NULL OR pi_email IS NULL 
       OR pi_phone IS NULL OR pi_house_number IS NULL OR pi_street IS NULL 
       OR pi_city IS NULL OR pi_state IS NULL 
       OR pi_country IS NULL OR pi_postal_code IS NULL THEN
        RAISE invalid_input;
    END IF;

    -- Check if customer already exists
    SELECT COUNT(*) INTO v_customer_count FROM CUSTOMER WHERE EMAIL = pi_email;
    IF v_customer_count > 0 THEN
        RAISE customer_exists;
    END IF;

    -- Insert into Address table
    INSERT INTO ADDRESS (HOUSE_NUMBER, STREET, CITY, STATE, COUNTRY, POSTAL_CODE)
    VALUES (pi_house_number, pi_street, pi_city, pi_state, pi_country, pi_postal_code)
    RETURNING ADDRESS_ID INTO v_address_id;

    -- Insert into Customer table
    INSERT INTO CUSTOMER (FIRST_NAME, LAST_NAME, ADDRESS_ID, PHONE_NUMBER, EMAIL)
    VALUES (pi_first_name, pi_last_name, v_address_id, pi_phone, pi_email);

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Customer record added successfully');

EXCEPTION
    WHEN invalid_input THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Invalid input arguments');
    WHEN customer_exists THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Customer with the same email already exists');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE(SQLERRM); -- Display the specific SQL error
END ADD_CUSTOMER_RECORD;
/


-- Grant execute permission to appropriate roles or users
GRANT EXECUTE ON ADD_CUSTOMER_RECORD TO manager_role;
GRANT EXECUTE ON ADD_CUSTOMER_RECORD TO sales_rep_role;

-- For John Doe
BEGIN
    ADD_CUSTOMER_RECORD(
        pi_first_name     => 'John',
        pi_last_name      => 'Doe',
        pi_phone          => '555-1234',
        pi_email          => 'johndoe@email.com',
        pi_house_number  => 567,
        pi_street        => 'Fifth St',
        pi_city          => 'Mass avenue',
        pi_state         => 'Tenesse',
        pi_country       => 'United States',
        pi_postal_code   => 20133
    );
END;
/

-- For Jane Smith
BEGIN
    ADD_CUSTOMER_RECORD(
        pi_first_name     => 'Jane',
        pi_last_name      => 'Smith',
        pi_phone          => '555-2345',
        pi_email          => 'janesmith@email.com',
        pi_house_number  => 456,
        pi_street        => 'Main Street',
        pi_city          => 'Anytown',
        pi_state         => 'State',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/

-- For Jim Bean
BEGIN
    ADD_CUSTOMER_RECORD(
        pi_first_name     => 'Jim',
        pi_last_name      => 'Bean',
        pi_phone          => '555-3456',
        pi_email          => 'jimbean@email.com',
        pi_house_number  => 345,
        pi_street        => 'Fourth St',
        pi_city          => 'East cottage st',
        pi_state         => 'Nebraska',
        pi_country       => 'United States',
        pi_postal_code   => 02122
    );
END;
/

-- For James Barnes
BEGIN
    ADD_CUSTOMER_RECORD(
        pi_first_name     => 'James',
        pi_last_name      => 'Barnes',
        pi_phone          => '555-4567',
        pi_email          => 'jamesbarnes@email.com',
        pi_house_number  => 234,
        pi_street        => 'Third St',
        pi_city          => 'Elder st',
        pi_state         => 'California',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/

-- For Jake Bond
BEGIN
    ADD_CUSTOMER_RECORD(
        pi_first_name     => 'Jake',
        pi_last_name      => 'Bond',
        pi_phone          => '555-5678',
        pi_email          => 'jakebond@email.com',
        pi_house_number  => 123,
        pi_street        => 'Main Street',
        pi_city          => 'Springfield',
        pi_state         => 'Massachusetts',
        pi_country       => 'United States',
        pi_postal_code   => 12345
    );
END;
/


CREATE OR REPLACE PROCEDURE PROCESS_PURCHASE(
    pi_vendor_id      IN VENDOR.VENDOR_ID%TYPE,
    pi_product_id     IN PRODUCT.PRODUCT_ID%TYPE,
    pi_units          IN PURCHASES.QUANTITY%TYPE,
    pi_buying_price   IN PURCHASES.BUYING_PRICE%TYPE
)
AS
     v_remaining_units INTEGER;
     v_vendor_id INTEGER;
     v_product_id INTEGER;
     invalid_input EXCEPTION;
BEGIN
    BEGIN
      SELECT vendor_id
      INTO v_vendor_id
      FROM VENDOR
      WHERE VENDOR_ID = pi_vendor_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Could not find vendor for id: ' || pi_vendor_id);
        RETURN;
    END;
    BEGIN
      SELECT product_id
      INTO v_product_id
      FROM PRODUCT
      WHERE PRODUCT_ID = pi_product_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Could not find product for id: ' || pi_product_id);
        RETURN;
    END;
    IF pi_units<1 THEN
        DBMS_OUTPUT.PUT_LINE('Provide valid count of products bought');
        RETURN;
    END IF;  
    
    IF pi_buying_price<0 THEN
        DBMS_OUTPUT.PUT_LINE('Provide valid buying price of product bought');
        RETURN;
    END IF;
    
    INSERT INTO PURCHASES (VENDOR_ID, PRODUCT_ID, PURCHASE_DATE, QUANTITY, BUYING_PRICE) VALUES (v_vendor_id, v_product_id, SYSTIMESTAMP, pi_units, pi_buying_price);
    
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Sucessfully recorded purchase');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred');    
END PROCESS_PURCHASE;
/
GRANT EXECUTE ON PROCESS_PURCHASE TO inventory_clerk_role;

CREATE OR REPLACE PROCEDURE ADD_PRODUCT (
    p_category IN Product.CATEGORY%TYPE,
    p_name IN Product.NAME%TYPE,
    p_remaining_units IN Product.REMAINING_UNITS%TYPE,
    p_selling_price IN Product.SELLING_PRICE%TYPE
) AS
BEGIN
    INSERT INTO Product (CATEGORY, NAME, REMAINING_UNITS, SELLING_PRICE) 
    VALUES (p_category, p_name, p_remaining_units, p_selling_price);

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE; -- Re-raise the exception for further handling or logging
END ADD_PRODUCT;
/

GRANT EXECUTE ON ADD_PRODUCT TO inventory_clerk_role;

BEGIN
    ADD_PRODUCT(
        p_category => 'Clothing',
        p_name => 'T-Shirt',
        p_remaining_units => 150,
        p_selling_price => 19.99
    );
END;
/

BEGIN
    ADD_PRODUCT(
        p_category => 'Groceries',
        p_name => 'Milk',
        p_remaining_units => 200,
        p_selling_price => 2.99
    );
END;
/

BEGIN
    ADD_PRODUCT(
        p_category => 'Cosmetics',
        p_name => 'Retinoid',
        p_remaining_units => 150,
        p_selling_price => 9.99
    );
END;
/

BEGIN
    ADD_PRODUCT(
        p_category => 'Shoes',
        p_name => 'Nike',
        p_remaining_units => 50,
        p_selling_price => 39.99
    );
END;
/

BEGIN
    ADD_PRODUCT(
        p_category => 'Electronics',
        p_name => 'Smartphone',
        p_remaining_units => 50,
        p_selling_price => 299.99
    );
END;
/

BEGIN
    PROCESS_PURCHASE(pi_vendor_id => 1, pi_product_id => 1, pi_units => 50, pi_buying_price => 17.99 );
END;
/

BEGIN
    PROCESS_PURCHASE(pi_vendor_id => 2, pi_product_id => 2, pi_units => 150, pi_buying_price => 2.45 );
END;
/

BEGIN
    PROCESS_PURCHASE(pi_vendor_id => 3, pi_product_id => 3, pi_units => 200, pi_buying_price => 8.19 );
END;
/

BEGIN
    PROCESS_PURCHASE(pi_vendor_id => 4, pi_product_id => 4, pi_units => 150, pi_buying_price => 34.89 );
END;
/

BEGIN
    PROCESS_PURCHASE(pi_vendor_id => 5, pi_product_id => 5, pi_units => 50, pi_buying_price => 295.99 );
END;
/


create or replace PROCEDURE UPDATE_EMPLOYEE_RECORD(
    pi_new_first_name       IN EMPLOYEE.first_name%TYPE DEFAULT NULL,
    pi_new_last_name        IN EMPLOYEE.last_name%TYPE DEFAULT NULL,
    pi_current_email        IN EMPLOYEE.email%TYPE,
    pi_new_email            IN EMPLOYEE.email%TYPE DEFAULT NULL,
    pi_new_phone            IN EMPLOYEE.phone_number%TYPE DEFAULT NULL,
    pi_new_hiring_date      IN EMPLOYEE.hiring_date%TYPE DEFAULT NULL,
    pi_new_role             IN EMPLOYEE.role%TYPE DEFAULT NULL,
    pi_new_wage             IN EMPLOYEE.wage%TYPE DEFAULT NULL,
    pi_new_house_number     IN ADDRESS.house_number%TYPE DEFAULT NULL,
    pi_new_street           IN ADDRESS.street%TYPE DEFAULT NULL,
    pi_new_city             IN ADDRESS.city%TYPE DEFAULT NULL,
    pi_new_state            IN ADDRESS.state%TYPE DEFAULT NULL,
    pi_new_country          IN ADDRESS.country%TYPE DEFAULT NULL,
    pi_new_postal_code      IN ADDRESS.postal_code%TYPE DEFAULT NULL,
    pi_new_last_date        IN EMPLOYEE.last_date%TYPE DEFAULT NULL
)
AS
    v_address_id ADDRESS.address_id%TYPE;
    v_employee_id EMPLOYEE.employee_id%TYPE;
    v_employee_count INTEGER;
    v_email_count INTEGER;
    invalid_input EXCEPTION;
    invalid_email EXCEPTION;
    email_invalid EXCEPTION;
    email_exists EXCEPTION;

BEGIN

    -- Validate current email input
    IF pi_current_email IS NULL THEN
        RAISE invalid_input;
    END IF;
    
    -- Check if employee with current email exists
    SELECT COUNT(*) INTO v_employee_count FROM EMPLOYEE WHERE EMAIL = pi_current_email;
    IF v_employee_count = 0 THEN
        RAISE invalid_email;
    END IF;
    
    -- Retrieve address and employee IDs
    SELECT ADDRESS_ID, EMPLOYEE_ID INTO v_address_id, v_employee_id FROM EMPLOYEE WHERE EMAIL = pi_current_email;

    -- Update address details
    UPDATE ADDRESS 
    SET HOUSE_NUMBER = COALESCE(pi_new_house_number, HOUSE_NUMBER), 
        STREET       = COALESCE(pi_new_street, STREET), 
        CITY         = COALESCE(pi_new_city, CITY), 
        STATE        = COALESCE(pi_new_state, STATE), 
        COUNTRY      = COALESCE(pi_new_country, COUNTRY), 
        POSTAL_CODE  = COALESCE(pi_new_postal_code, POSTAL_CODE)
    WHERE ADDRESS_ID = v_address_id;
    
    -- Validate and update new email, if provided
    IF pi_new_email IS NOT NULL THEN
        IF NOT VALIDATE_EMAIL(pi_new_email) THEN
            RAISE email_invalid;
        END IF;
        
        -- Check if new email already exists in EMPLOYEE table
        SELECT COUNT(*) INTO v_email_count
        FROM EMPLOYEE
        WHERE EMAIL = pi_new_email;
        
        IF v_email_count > 0 THEN
            RAISE email_exists;
        END IF;

        UPDATE EMPLOYEE SET EMAIL = pi_new_email
            WHERE EMAIL = pi_current_email;
    END IF;
    
    -- Update other employee details
    UPDATE EMPLOYEE
    SET FIRST_NAME   = COALESCE(pi_new_first_name, FIRST_NAME),
        LAST_NAME    = COALESCE(pi_new_last_name, LAST_NAME),
        PHONE_NUMBER = COALESCE(pi_new_phone, PHONE_NUMBER),
        HIRING_DATE  = COALESCE(pi_new_hiring_date, HIRING_DATE),
        ROLE         = COALESCE(pi_new_role, ROLE),
        WAGE         = COALESCE(pi_new_wage, WAGE),
        LAST_DATE    = COALESCE(pi_new_last_date, LAST_DATE)
    WHERE EMPLOYEE_ID = v_employee_id;

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Employee details updated successfully');

EXCEPTION
    WHEN invalid_input THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: You need to provide a valid existing current email');
    WHEN invalid_email THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: No employee found with given email');
    WHEN email_invalid THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Invalid email format');
    WHEN email_exists THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: The new email provided already exists');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
END UPDATE_EMPLOYEE_RECORD;
/


GRANT EXECUTE ON UPDATE_EMPLOYEE_RECORD TO MANAGER_ROLE;

CREATE OR REPLACE PROCEDURE UPDATE_VENDOR_RECORD(
    pi_email            IN VENDOR.EMAIL%TYPE,
    pi_name             IN VENDOR.NAME%TYPE DEFAULT NULL,
    pi_phone            IN VENDOR.PHONE_NUMBER%TYPE DEFAULT NULL,
    pi_newEmail         IN VENDOR.EMAIL%TYPE DEFAULT NULL,
    pi_house_number     IN ADDRESS.HOUSE_NUMBER%TYPE DEFAULT NULL,
    pi_street           IN ADDRESS.STREET%TYPE DEFAULT NULL,
    pi_city             IN ADDRESS.CITY%TYPE DEFAULT NULL,
    pi_state            IN ADDRESS.STATE%TYPE DEFAULT NULL,
    pi_country          IN ADDRESS.COUNTRY%TYPE DEFAULT NULL,
    pi_postal_code      IN ADDRESS.POSTAL_CODE%TYPE DEFAULT NULL,
    pi_last_date        IN VENDOR.LAST_DATE%TYPE DEFAULT NULL
)
AS
    vendor_count INTEGER;
BEGIN
    -- Check if vendor exists with the given email
    SELECT COUNT(*) INTO vendor_count
    FROM VENDOR
    WHERE EMAIL = pi_email;

    IF vendor_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Vendor not found with the provided email');
        RAISE_APPLICATION_ERROR(-20001, 'Vendor not found with the provided email');
    END IF;

    -- Update Vendor table
    UPDATE VENDOR
    SET NAME         = NVL(pi_name, NAME),
        PHONE_NUMBER = NVL(pi_phone, PHONE_NUMBER),
        LAST_DATE    = NVL(pi_last_date, LAST_DATE)
    WHERE EMAIL = pi_email;
    
    DBMS_OUTPUT.PUT_LINE('Vendor name and phone updated');

    -- Update Address table
    -- Assuming an address record exists and is linked to the vendor
    UPDATE ADDRESS
    SET HOUSE_NUMBER = NVL(pi_house_number, HOUSE_NUMBER),
        STREET = NVL(pi_street, STREET),
        CITY = NVL(pi_city, CITY),
        STATE = NVL(pi_state, STATE),
        COUNTRY = NVL(pi_country, COUNTRY),
        POSTAL_CODE = NVL(pi_postal_code, POSTAL_CODE)
    WHERE ADDRESS_ID = (SELECT ADDRESS_ID FROM VENDOR WHERE EMAIL = pi_email);
    
    DBMS_OUTPUT.PUT_LINE('Address updated');
        -- If a new email is provided, check if it's unique
    IF pi_newEmail IS NOT NULL THEN
        SELECT COUNT(*) INTO vendor_count
        FROM VENDOR
        WHERE EMAIL = pi_newEmail;
        DBMS_OUTPUT.PUT_LINE('New email provided updated');

        IF vendor_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('New email provided already exists');
            RAISE_APPLICATION_ERROR(-20002, 'New email provided already exists');
        END IF;
        IF vendor_count = 0 THEN
            UPDATE VENDOR SET EMAIL = pi_newEmail
                WHERE EMAIL = pi_email;
        END IF;
    END IF;

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Vendor record updated successfully');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An error has occurred during procedure execution');
END UPDATE_VENDOR_RECORD;
/

GRANT EXECUTE ON UPDATE_VENDOR_RECORD TO MANAGER_ROLE;



CREATE OR REPLACE PROCEDURE UPDATE_CUSTOMER_RECORD(
    pi_current_email IN CUSTOMER.EMAIL%TYPE,
    pi_new_email     IN CUSTOMER.EMAIL%TYPE DEFAULT NULL,
    pi_first_name    IN CUSTOMER.FIRST_NAME%TYPE DEFAULT NULL,
    pi_last_name     IN CUSTOMER.LAST_NAME%TYPE DEFAULT NULL,
    pi_phone         IN CUSTOMER.PHONE_NUMBER%TYPE DEFAULT NULL,
    pi_house_number  IN ADDRESS.HOUSE_NUMBER%TYPE DEFAULT NULL,
    pi_street        IN ADDRESS.STREET%TYPE DEFAULT NULL,
    pi_city          IN ADDRESS.CITY%TYPE DEFAULT NULL,
    pi_state         IN ADDRESS.STATE%TYPE DEFAULT NULL,
    pi_country       IN ADDRESS.COUNTRY%TYPE DEFAULT NULL,
    pi_postal_code   IN ADDRESS.POSTAL_CODE%TYPE DEFAULT NULL
)
AS
    v_address_id ADDRESS.ADDRESS_ID%TYPE;
    email_already_exists EXCEPTION;
    invalid_email EXCEPTION;
    customer_not_found EXCEPTION;
BEGIN
    -- Validate the new email if provided
    IF pi_new_email IS NOT NULL AND NOT VALIDATE_EMAIL(pi_new_email) THEN
        RAISE invalid_email;
    END IF;

    -- Check if the new email already exists for another customer
    IF pi_new_email IS NOT NULL AND EMAIL_EXISTS(pi_new_email, 'CUSTOMER') = 1 AND pi_new_email != pi_current_email THEN
        RAISE email_already_exists;
    END IF;

    -- Check if customer exists and get address ID
    BEGIN
        SELECT ADDRESS_ID INTO v_address_id FROM CUSTOMER WHERE EMAIL = pi_current_email;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE customer_not_found;
    END;

    -- Update Customer table
    IF pi_first_name IS NOT NULL OR pi_last_name IS NOT NULL OR 
       pi_phone IS NOT NULL OR pi_new_email IS NOT NULL THEN

        UPDATE CUSTOMER
        SET FIRST_NAME = COALESCE(pi_first_name, FIRST_NAME),
            LAST_NAME = COALESCE(pi_last_name, LAST_NAME),
            PHONE_NUMBER = COALESCE(pi_phone, PHONE_NUMBER),
            EMAIL = COALESCE(pi_new_email, EMAIL)
        WHERE EMAIL = pi_current_email;
    END IF;

    -- Update Address table
    IF pi_house_number IS NOT NULL OR pi_street IS NOT NULL OR pi_city IS NOT NULL OR
       pi_state IS NOT NULL OR pi_country IS NOT NULL OR pi_postal_code IS NOT NULL THEN

        UPDATE ADDRESS
        SET HOUSE_NUMBER = COALESCE(pi_house_number, HOUSE_NUMBER),
            STREET = COALESCE(pi_street, STREET),
            CITY = COALESCE(pi_city, CITY),
            STATE = COALESCE(pi_state, STATE),
            COUNTRY = COALESCE(pi_country, COUNTRY),
            POSTAL_CODE = COALESCE(pi_postal_code, POSTAL_CODE)
        WHERE ADDRESS_ID = v_address_id;
    END IF;

    DBMS_OUTPUT.PUT_LINE('Customer and address records updated successfully');

    COMMIT;
EXCEPTION
    WHEN invalid_email THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Provided new email is invalid');
    WHEN email_already_exists THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: New email already in use by another customer');
    WHEN customer_not_found THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Customer record not found for the given current email');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END UPDATE_CUSTOMER_RECORD;
/

GRANT EXECUTE ON UPDATE_CUSTOMER_RECORD TO manager_role;
GRANT EXECUTE ON UPDATE_CUSTOMER_RECORD TO sales_rep_role;

CREATE OR REPLACE PROCEDURE DELETE_CUSTOMER_RECORD(
    pi_email IN CUSTOMER.EMAIL%TYPE
)
AS
    v_customer_id CUSTOMER.CUSTOMER_ID%TYPE;
    v_address_id ADDRESS.ADDRESS_ID%TYPE;
    customer_not_found EXCEPTION;
BEGIN
    -- Retrieve customer ID and address ID based on email
    SELECT CUSTOMER_ID, ADDRESS_ID INTO v_customer_id, v_address_id 
    FROM CUSTOMER WHERE EMAIL = pi_email;

    -- Delete the customer record
    DELETE FROM CUSTOMER WHERE CUSTOMER_ID = v_customer_id;

    -- Delete the address record
    DELETE FROM ADDRESS WHERE ADDRESS_ID = v_address_id;

    DBMS_OUTPUT.PUT_LINE('Customer and address records deleted successfully');

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE customer_not_found;
    WHEN customer_not_found THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: Customer record not found');
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END DELETE_CUSTOMER_RECORD;
/



CREATE OR REPLACE TYPE product_type FORCE AS OBJECT (
    name VARCHAR2(100),
    category VARCHAR2(100),
    units NUMBER
);
/

CREATE OR REPLACE TYPE product_id_type FORCE AS OBJECT (
    product_id NUMBER
);
/

CREATE OR REPLACE TYPE product_price_type FORCE AS OBJECT (

    product_price NUMBER

);
/

CREATE OR REPLACE TYPE product_list_type FORCE AS TABLE OF product_type;
/

CREATE OR REPLACE TYPE product_id_list_type FORCE AS TABLE OF product_id_type;
/

CREATE OR REPLACE TYPE product_price_list_type FORCE AS TABLE OF product_price_type;
/


grant execute on product_type to manager_role;
grant execute on product_id_type to manager_role;
grant execute on product_list_type to manager_role;
grant execute on product_id_list_type to manager_role;

grant execute on product_type to sales_rep_role;
grant execute on product_id_type to sales_rep_role;
grant execute on product_list_type to sales_rep_role;
grant execute on product_id_list_type to sales_rep_role;


CREATE OR REPLACE PROCEDURE process_products(
    pi_products       IN product_list_type,
    pi_customer_email IN CUSTOMER.EMAIL%TYPE,
    pi_employee_email IN EMPLOYEE.EMAIL%TYPE
)
AS
     v_error_found BOOLEAN := FALSE;
     v_customer_id INTEGER;
     v_employee_id INTEGER;
     v_record_count INTEGER;
     v_remaining_units INTEGER;
     v_product_id PRODUCT.PRODUCT_ID%TYPE;
     v_product_price PRODUCT.SELLING_PRICE%TYPE;
     v_order_id ORDERS.ORDER_ID%TYPE;
     v_product_ids product_id_list_type := product_id_list_type();
     v_product_prices product_price_list_type := product_price_list_type();
     e_customer_not_found EXCEPTION;
     e_employee_not_found EXCEPTION;
     e_incorrect_data EXCEPTION;
     e_no_product EXCEPTION;
     e_no_units EXCEPTION;
BEGIN

    SELECT COUNT(*) INTO v_record_count FROM CUSTOMER WHERE LOWER(EMAIL) = LOWER(pi_customer_email);
    
    IF v_record_count = 0 THEN
        RAISE e_customer_not_found;
    END IF;
    
        -- Validate customer email
    BEGIN
      SELECT customer_id
      INTO v_customer_id
      FROM CUSTOMER
      WHERE LOWER(EMAIL) = LOWER(pi_customer_email);
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Could not find customer for email: ' || pi_customer_email);
        RAISE_APPLICATION_ERROR(-20002, 'Customer not found for email: ' || pi_customer_email);
    END;
    
    SELECT COUNT(*) INTO v_record_count FROM EMPLOYEE WHERE LOWER(EMAIL) = LOWER(pi_employee_email);
    
    IF v_record_count = 0 THEN
        RAISE e_employee_not_found;
    END IF;

    BEGIN
      SELECT employee_id
      INTO v_employee_id
      FROM EMPLOYEE
      WHERE LOWER(EMAIL) = LOWER(pi_employee_email);
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Could not find employee for email: ' || pi_employee_email);
        RAISE_APPLICATION_ERROR(-20003, 'Employee not found for email: ' || pi_employee_email);
    END;


    FOR i IN 1..pi_products.COUNT LOOP
        IF pi_products(i).name IS NULL OR pi_products(i).category IS NULL OR pi_products(i).units IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('Error: Incomplete product data for product ' || i);
            v_error_found := TRUE;
        END IF;
    END LOOP;
    
    IF v_error_found THEN
        DBMS_OUTPUT.PUT_LINE('Provide all the fields for the product details');
        RAISE e_incorrect_data;
    END IF;
    
    FOR i IN 1..pi_products.COUNT LOOP
        BEGIN
            SELECT PRODUCT_ID, SELLING_PRICE INTO v_product_id, v_product_price
            FROM PRODUCT
            WHERE LOWER(NAME) = LOWER(pi_products(i).name)
            AND LOWER(CATEGORY) = LOWER(pi_products(i).category);
            
        IF v_product_id IS NOT NULL THEN
            DBMS_OUTPUT.PUT_LINE('Product ID: ' || v_product_id);
            v_product_ids.EXTEND;
            v_product_ids(v_product_ids.COUNT) := product_id_type(product_id => v_product_id);
            
            v_product_prices.EXTEND;
            v_product_prices(v_product_prices.COUNT) := product_price_type(product_price => v_product_price);
            
        END IF;
    
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.PUT_LINE('Error: Product not found for name: ' || pi_products(i).name || ' and category: ' || pi_products(i).category);
                v_error_found := TRUE;
        
        END;
    
    
    END LOOP;
    
    IF v_error_found THEN
        RAISE e_no_product;
    END IF;    
    
    FOR i IN 1..v_product_ids.COUNT LOOP
    
        SELECT REMAINING_UNITS INTO v_remaining_units FROM PRODUCT WHERE PRODUCT_ID = v_product_ids(i).product_id;
        
        IF v_remaining_units < pi_products(i).units THEN
          DBMS_OUTPUT.PUT_LINE('Insufficient units for product (ID: ' || v_product_ids(i).product_id || '). Requested: ' || pi_products(i).units || ', Available: ' || v_remaining_units);
          v_error_found := TRUE;
        END IF;
        
    END LOOP;
    
    IF v_error_found THEN
        RAISE e_no_units;
    END IF;
    
    INSERT INTO ORDERS (CUSTOMER_ID, EMPLOYEE_ID, ORDER_DATE) VALUES (v_customer_id, v_employee_id, SYSTIMESTAMP )
    RETURNING ORDER_ID INTO v_order_id;
    
    FOR i IN 1..v_product_ids.COUNT LOOP
    
        INSERT INTO ITEM_ORDERS (ORDER_ID, PRODUCT_ID, SELLING_PRICE, UNITS) VALUES (v_order_id, v_product_ids(i).product_id,v_product_prices(i).product_price, pi_products(i).units);
        
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('Sucessfully recorded order');
    
    COMMIT;

EXCEPTION

    WHEN e_customer_not_found THEN
        DBMS_OUTPUT.PUT_LINE('Could not find customer email');
    WHEN e_employee_not_found THEN
        DBMS_OUTPUT.PUT_LINE('Could not find employee email');
    WHEN e_incorrect_data THEN
        DBMS_OUTPUT.PUT_LINE('Provide all the fields [Name, Category, Units] for the product details');
    WHEN e_no_product THEN
        DBMS_OUTPUT.PUT_LINE('Could not get product with the specified details');
    WHEN e_no_units THEN
        DBMS_OUTPUT.PUT_LINE('Insufficient units in stock. Cannot place the order.');
    
END process_products;
/

GRANT EXECUTE ON process_products TO sales_rep_role;
GRANT EXECUTE ON process_products TO manager_role;

CREATE OR REPLACE TRIGGER update_product_stock
AFTER INSERT ON ITEM_ORDERS
FOR EACH ROW
DECLARE
  v_product_id PRODUCT.PRODUCT_ID%TYPE;
  v_remaining_units NUMBER;
  v_ordered_units NUMBER;
BEGIN
  v_product_id := :NEW.PRODUCT_ID;
  v_ordered_units := :NEW.UNITS;

  UPDATE PRODUCT
  SET REMAINING_UNITS = REMAINING_UNITS - v_ordered_units
  WHERE PRODUCT_ID = v_product_id;

  IF SQL%NOTFOUND THEN
    RAISE_APPLICATION_ERROR(-20001, 'Product not found for order (ID: ' || v_product_id || ')');
  END IF;
END;
/

  
DECLARE
    v_products product_list_type := product_list_type(
        product_type('Smartphone', 'Electronics', 1),
        product_type('Milk', 'Groceries', 2)
    );
BEGIN
    process_products(pi_products=>v_products, pi_customer_email=>'johndoe@email.com', pi_employee_email=>'jane@email.com');
END;
/

DECLARE
    v_products product_list_type := product_list_type(
        product_type('Nike', 'Shoes', 2),
        product_type('Retinoid', 'Cosmetics', 4),
        product_type('Milk', 'Groceries', 3)
    );
BEGIN
    process_products(pi_products=>v_products, pi_customer_email=>'jimbean@email.com', pi_employee_email=>'carter@email.com');
END;
/

DECLARE
    v_products product_list_type := product_list_type(
        product_type('Nike', 'Shoes', 6),
        product_type('Milk', 'Groceries', 2)
    );
BEGIN
    process_products(pi_products=>v_products, pi_customer_email=>'jamesbarnes@email.com', pi_employee_email=>'carter@email.com');
END;
/


CREATE OR REPLACE TRIGGER UPDATE_PRODUCT_QUANTITY_AFTER_PURCHASE
AFTER INSERT ON PURCHASES
FOR EACH ROW
DECLARE
  v_product_id PRODUCT.PRODUCT_ID%TYPE;
  v_remaining_units NUMBER;
  v_ordered_units NUMBER;
BEGIN
  v_product_id := :NEW.PRODUCT_ID;
  v_ordered_units := :NEW.QUANTITY;
  UPDATE PRODUCT
  SET REMAINING_UNITS = REMAINING_UNITS + v_ordered_units
  WHERE PRODUCT_ID = v_product_id;
  IF SQL%NOTFOUND THEN
    RAISE_APPLICATION_ERROR(-20001, 'Product not found for order (ID: ' || v_product_id || ')');
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE UPDATE_PRODUCT_NAME_CATEGORY (
    p_product_id IN Product.PRODUCT_ID%TYPE,
    p_category IN Product.CATEGORY%TYPE DEFAULT NULL,
    p_name IN Product.NAME%TYPE DEFAULT NULL
) AS
BEGIN
    -- Check if both parameters are NULL
    IF p_category IS NULL AND p_name IS NULL THEN
        RAISE_APPLICATION_ERROR(-20003, 'No update information provided');
    END IF;

    -- Update Product table
    UPDATE Product
    SET CATEGORY = COALESCE(p_category, CATEGORY),
        NAME = COALESCE(p_name, NAME)
    WHERE PRODUCT_ID = p_product_id;

    -- Check if the update was successful
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'No product found with the given PRODUCT_ID');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE; -- Re-raise the exception for further handling
END UPDATE_PRODUCT_NAME_CATEGORY;
/

GRANT EXECUTE ON UPDATE_PRODUCT_NAME_CATEGORY TO inventory_clerk_role;

CREATE OR REPLACE PROCEDURE UPDATE_PRODUCT (
    p_product_id IN Product.PRODUCT_ID%TYPE,
    p_category IN Product.CATEGORY%TYPE DEFAULT NULL,
    p_name IN Product.NAME%TYPE DEFAULT NULL,
    p_remaining_units IN Product.REMAINING_UNITS%TYPE DEFAULT NULL,
    p_selling_price IN Product.SELLING_PRICE%TYPE DEFAULT NULL
) AS
BEGIN
    UPDATE Product
    SET CATEGORY = COALESCE(p_category, CATEGORY),
        NAME = COALESCE(p_name, NAME),
        REMAINING_UNITS = COALESCE(p_remaining_units, REMAINING_UNITS),
        SELLING_PRICE = COALESCE(p_selling_price, SELLING_PRICE)
    WHERE PRODUCT_ID = p_product_id;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'No product found with the given PRODUCT_ID');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE; -- Re-raise the exception for further handling
END UPDATE_PRODUCT;
/



CREATE OR REPLACE VIEW STORE_PRODUCTS AS (
    SELECT * FROM PRODUCT
);

GRANT SELECT ON STORE_PRODUCTS TO manager_role;
GRANT SELECT ON STORE_PRODUCTS TO sales_rep_role;
GRANT SELECT ON STORE_PRODUCTS TO accountant_role;
GRANT SELECT ON STORE_PRODUCTS TO inventory_clerk_role;

CREATE OR REPLACE VIEW STORE_EMPLOYEES AS (
    SELECT 
        EMPLOYEE_ID, 
        INITCAP(FIRST_NAME) as FIRST_NAME, 
        INITCAP(LAST_NAME) as LAST_NAME, 
        LOWER(EMAIL) as CUSTOMER_EMAIL, 
        WAGE, 
        TO_CHAR(TRUNC(HIRING_DATE), 'DDth MON YYYY') AS HIRING_DATE, 
        INITCAP(STREET) as STREET, 
        INITCAP(CITY) as CITY, 
        INITCAP(STATE) as STATE, 
        INITCAP(COUNTRY) as COUNTRY, 
        POSTAL_CODE 
    FROM EMPLOYEE INNER JOIN ADDRESS ON EMPLOYEE.ADDRESS_ID = ADDRESS.ADDRESS_ID
);

GRANT SELECT ON STORE_EMPLOYEES TO manager_role;

CREATE OR REPLACE VIEW STORE_CUSTOMERS AS (
  select CUSTOMER_ID, 
    INITCAP(FIRST_NAME) as FIRST_NAME, 
    INITCAP(LAST_NAME) as LAST_NAME, 
    LOWER(EMAIL) as CUSTOMER_EMAIL, 
    INITCAP(STREET) as STREET, 
    INITCAP(CITY) as CITY, 
    INITCAP(STATE) as STATE, 
    INITCAP(COUNTRY) as COUNTRY, 
    POSTAL_CODE 
    FROM CUSTOMER INNER JOIN ADDRESS ON CUSTOMER.ADDRESS_ID = ADDRESS.ADDRESS_ID
);

GRANT SELECT ON STORE_CUSTOMERS TO manager_role;
GRANT SELECT ON STORE_CUSTOMERS TO sales_rep_role;


CREATE OR REPLACE VIEW STORE_VENDORS AS (
 SELECT VENDOR_ID, 
    INITCAP(NAME) as VENDOR_NAME, 
    LOWER(EMAIL) as VENDOR_EMAIL, 
    INITCAP(STREET) as STREET, 
    INITCAP(CITY) as CITY, 
    INITCAP(STATE) as STATE, 
    INITCAP(COUNTRY) as COUNTRY, 
    POSTAL_CODE 
    FROM ADDRESS INNER JOIN VENDOR ON VENDOR.ADDRESS_ID = ADDRESS.ADDRESS_ID
);

GRANT SELECT ON STORE_VENDORS TO manager_role;
GRANT SELECT ON STORE_VENDORS TO inventory_clerk_role;

CREATE OR REPLACE VIEW STORE_PURCHASES AS (
  SELECT TRANSACTION_ID, 
    TO_CHAR(TRUNC(PURCHASE_DATE), 'DDth MON YYYY') AS PURCHASE_DATE, 
    VENDOR.VENDOR_ID, 
    INITCAP(VENDOR.NAME) AS VENDOR_NAME, 
    QUANTITY, 
    PURCHASES.PRODUCT_ID, 
    INITCAP(PRODUCT.NAME) AS PRODUCT_NAME, 
    INITCAP(PRODUCT.CATEGORY) AS PRODUCT_CATEGORY, 
    REMAINING_UNITS 
    FROM PURCHASES INNER JOIN VENDOR ON PURCHASES.VENDOR_ID = VENDOR.VENDOR_ID INNER JOIN PRODUCT ON PURCHASES.PRODUCT_ID = PRODUCT.PRODUCT_ID
);

GRANT SELECT ON STORE_PURCHASES TO accountant_role;
GRANT SELECT ON STORE_PURCHASES TO inventory_clerk_role;

CREATE OR REPLACE VIEW STORE_ORDERS AS (
   SELECT ORDERS.ORDER_ID, 
        ORDERS.EMPLOYEE_ID, 
        INITCAP(FIRST_NAME) || ' ' || INITCAP(LAST_NAME) AS CUSTOMER_NAME, 
        LOWER(EMAIL) as CUSTOMER_EMAIL, 
        TO_CHAR(TRUNC(order_date), 'DDth MON YYYY') AS order_date, 
        PRODUCT.PRODUCT_ID, 
        INITCAP(PRODUCT.NAME) AS PRODUCT_NAME, 
        INITCAP(PRODUCT.CATEGORY) AS PRODUCT_CATEGORY, 
        UNITS, 
        UNITS * ITEM_ORDERS.SELLING_PRICE AS TOTAL_COST 
        FROM orders inner join item_orders on orders.order_id = item_orders.order_id 
            inner join customer on customer.customer_id = orders.customer_id 
            INNER JOIN PRODUCT ON PRODUCT.PRODUCT_ID = ITEM_ORDERS.PRODUCT_ID
);

GRANT SELECT ON STORE_ORDERS TO accountant_role;
GRANT SELECT ON STORE_ORDERS TO sales_rep_role;


CREATE OR REPLACE VIEW PRODUCT_PROFIT_PER_SALE AS
WITH TEMP AS (
    SELECT PRODUCT_ID, 
           SUM(BUYING_PRICE)/COUNT(BUYING_PRICE) AS AVG_BUYING_PRICE 
    FROM PURCHASES
    GROUP BY PRODUCT_ID
)
SELECT TEMP.PRODUCT_ID, 
       INITCAP(PRODUCT.CATEGORY) AS PRODUCT_CATEGORY, 
       INITCAP(PRODUCT.NAME) AS PRODUCT_NAME, 
       TEMP.AVG_BUYING_PRICE, 
       PRODUCT.SELLING_PRICE, 
       ROUND(100 * (PRODUCT.SELLING_PRICE - TEMP.AVG_BUYING_PRICE) / TEMP.AVG_BUYING_PRICE, 3) || '%' AS PROFIT_PER_SALE 
FROM TEMP 
INNER JOIN PRODUCT ON TEMP.PRODUCT_ID = PRODUCT.PRODUCT_ID;

GRANT SELECT ON PRODUCT_PROFIT_PER_SALE TO ACCOUNTANT;

CREATE OR REPLACE PROCEDURE UPDATE_ORDER_RECORD(
    pi_order_id      IN ORDERS.ORDER_ID%TYPE,
    pi_product_id     IN PRODUCT.PRODUCT_ID%TYPE,
    pi_updated_units IN PRODUCT.REMAINING_UNITS%TYPE
)
AS
    v_order_count NUMBER;
    v_product_count NUMBER;
    v_order_placed NUMBER;
    v_remaining_units NUMBER;
    v_current_count NUMBER;
    invalid_input EXCEPTION;
    invalid_order EXCEPTION;
    invalid_product EXCEPTION;
    invalid_units EXCEPTION;
    no_order_with_product EXCEPTION;
    insufficient_units EXCEPTION;
BEGIN

    IF pi_order_id IS NULL OR pi_product_id IS NULL OR pi_updated_units IS NULL THEN
        RAISE invalid_input;
    END IF;
    
    SELECT COUNT(*) INTO v_order_count FROM ORDERS WHERE ORDER_ID = pi_order_id;
    
    IF v_order_count = 0 THEN
        RAISE invalid_order;
    END IF;

    SELECT COUNT(*) INTO v_product_count FROM PRODUCT WHERE PRODUCT_ID = pi_product_id;
    
    IF v_product_count = 0 THEN
        RAISE invalid_product;
    END IF;

    SELECT COUNT(*) INTO v_order_placed FROM ITEM_ORDERS WHERE ORDER_ID = pi_order_id AND PRODUCT_ID = pi_product_id;
    
    IF v_order_placed = 0 THEN
        RAISE no_order_with_product;
    END IF;
    
    SELECT REMAINING_UNITS INTO v_remaining_units FROM PRODUCT WHERE PRODUCT_ID = pi_product_id;
    
    
    SELECT UNITS INTO v_current_count FROM ITEM_ORDERS WHERE ORDER_ID = pi_order_id AND PRODUCT_ID = pi_product_id;
    
    IF pi_updated_units < 0 THEN
        RAISE invalid_units;
    END IF;
    
    IF v_remaining_units - pi_updated_units < 0 THEN
        RAISE insufficient_units;
    END IF;
    
    UPDATE ITEM_ORDERS SET UNITS = pi_updated_units WHERE ORDER_ID = pi_order_id AND PRODUCT_ID = pi_product_id;
    

    DBMS_OUTPUT.PUT_LINE('Order updated successfully');

    COMMIT;
    
EXCEPTION
    WHEN invalid_input THEN
        DBMS_OUTPUT.PUT_LINE('Error: Provide all the fields required.');
        ROLLBACK; 
    WHEN invalid_order THEN
        DBMS_OUTPUT.PUT_LINE('Error: No Order Id exists');
        ROLLBACK;
    WHEN invalid_product THEN
        DBMS_OUTPUT.PUT_LINE('Error: No product exists with provided product ID');
        ROLLBACK;
    WHEN invalid_units THEN
        DBMS_OUTPUT.PUT_LINE('Error: Please provide positive number of units');
        ROLLBACK;
    WHEN no_order_with_product THEN
        DBMS_OUTPUT.PUT_LINE('Error: Could not find a record with given order_id and product_id');
        ROLLBACK;
    WHEN insufficient_units THEN
        DBMS_OUTPUT.PUT_LINE('Error: Insufficient units in stock');
        ROLLBACK;
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END UPDATE_ORDER_RECORD;
/

CREATE OR REPLACE TRIGGER after_order_update
AFTER UPDATE ON ITEM_ORDERS
FOR EACH ROW
WHEN (OLD.UNITS <> NEW.UNITS)
BEGIN
    IF :OLD.UNITS > :NEW.UNITS THEN
        UPDATE PRODUCT SET REMAINING_UNITS = REMAINING_UNITS + (:OLD.UNITS - :NEW.UNITS) WHERE PRODUCT_ID = :NEW.PRODUCT_ID;
    END IF;
    
    IF :OLD.UNITS < :NEW.UNITS THEN
        UPDATE PRODUCT SET REMAINING_UNITS = REMAINING_UNITS - (:NEW.UNITS - :OLD.UNITS) WHERE PRODUCT_ID = :NEW.PRODUCT_ID;
    END IF;

END;
/

GRANT EXECUTE ON UPDATE_ORDER_RECORD TO sales_rep_role;
GRANT EXECUTE ON UPDATE_ORDER_RECORD TO manager_role;


CREATE OR REPLACE PROCEDURE UPDATE_PURCHASE (
    
    pi_transaction_id   IN PURCHASES.TRANSACTION_ID%TYPE,
    pi_new_quantity     IN PURCHASES.TRANSACTION_ID%TYPE DEFAULT NULL,
    pi_new_buying_price IN PURCHASES.BUYING_PRICE%TYPE DEFAULT NULL

) 
AS
    v_transaction_count NUMBER;
    v_current_quantity NUMBER;
    v_product_id NUMBER;
    v_remaning_units NUMBER;
    e_invalid_input EXCEPTION;
    e_transaction_not_found EXCEPTION;
    e_invalid_quantity EXCEPTION;
    e_invalid_buying_price EXCEPTION;
    e_contact_owner EXCEPTION;
    
BEGIN

    IF pi_new_quantity IS NULL AND pi_new_buying_price IS NULL THEN
        RAISE e_invalid_input;
    END IF;

    SELECT COUNT(*) INTO v_transaction_count FROM PURCHASES WHERE TRANSACTION_ID = pi_transaction_id;
    
    IF v_transaction_count = 0 THEN
        RAISE e_transaction_not_found;
    END IF;

    
    IF pi_new_quantity < 0 THEN
        RAISE e_invalid_quantity;
    END IF;
    
    IF pi_new_buying_price < 0 THEN
        RAISE e_invalid_buying_price;
    END IF;
    
    IF pi_new_quantity IS NOT NULL THEN
    
        SELECT PRODUCT_ID, QUANTITY INTO v_product_id, v_current_quantity FROM PURCHASES WHERE TRANSACTION_ID = pi_transaction_id;
        
        SELECT REMAINING_UNITS INTO v_remaning_units FROM PRODUCT WHERE PRODUCT_ID = v_product_id;
        
        IF pi_new_quantity < v_current_quantity AND v_remaning_units - (v_current_quantity - pi_new_quantity) < 0 THEN
        
            RAISE e_contact_owner;
        END IF;
    
    END IF;
    
    
    
    UPDATE PURCHASES SET QUANTITY = NVL(pi_new_quantity, QUANTITY), BUYING_PRICE = NVL(pi_new_buying_price, BUYING_PRICE)
        WHERE TRANSACTION_ID = pi_transaction_id;
    
    DBMS_OUTPUT.PUT_LINE('Transaction updated successfully');
    
    COMMIT;

EXCEPTION
    
    WHEN e_invalid_input THEN 
      DBMS_OUTPUT.PUT_LINE('Specify atleast one of the following : pi_new_buying_price or pi_new_quantity');
    
    WHEN e_invalid_quantity THEN
      DBMS_OUTPUT.PUT_LINE('Quantity cannot be less than 0');
    
    WHEN e_invalid_buying_price THEN
      DBMS_OUTPUT.PUT_LINE('Price cannot be less than 0');
    
    WHEN e_transaction_not_found THEN
      DBMS_OUTPUT.PUT_LINE('Invalid transaction ID');
    
    WHEN e_contact_owner THEN
      DBMS_OUTPUT.PUT_LINE('Could not process the update. The product stock will go to negative. Please contact the store owner.');


END;
/


CREATE OR REPLACE TRIGGER AFTER_PURCHASES_UPDATE
AFTER UPDATE ON PURCHASES
FOR EACH ROW
WHEN (OLD.QUANTITY <> NEW.QUANTITY)
BEGIN
    IF :OLD.QUANTITY > :NEW.QUANTITY THEN
        UPDATE PRODUCT SET REMAINING_UNITS = REMAINING_UNITS - (:OLD.QUANTITY - :NEW.QUANTITY) WHERE PRODUCT_ID = :NEW.PRODUCT_ID;
    END IF;
    
    IF :OLD.QUANTITY < :NEW.QUANTITY THEN
        UPDATE PRODUCT SET REMAINING_UNITS = REMAINING_UNITS + (:NEW.QUANTITY - :OLD.QUANTITY) WHERE PRODUCT_ID = :NEW.PRODUCT_ID;
    END IF;

END;
/

CREATE OR REPLACE VIEW PRODUCT_OVERVIEW AS 
SELECT 
    p.PRODUCT_ID, 
    INITCAP(p.NAME) AS PRODUCT_NAME, 
    INITCAP(p.CATEGORY) AS PRODUCT_CATEGORY,
    SUM(i.UNITS) AS TOTAL_UNITS_SOLD, 
    SUM(i.UNITS * i.SELLING_PRICE) AS TOTAL_REVENUE,
    SUM(i.UNITS * (
        SELECT AVG(BUYING_PRICE) 
        FROM PURCHASES 
        WHERE PRODUCT_ID = p.PRODUCT_ID
    )) AS TOTAL_PURCHASE_COST,
    ROUND((
        (SUM(i.UNITS * i.SELLING_PRICE) - 
        SUM(i.UNITS * (
            SELECT AVG(BUYING_PRICE) 
            FROM PURCHASES 
            WHERE PRODUCT_ID = p.PRODUCT_ID
        ))) / SUM(i.UNITS * i.SELLING_PRICE)
    ) * 100, 2) || '%' AS PROFIT
FROM 
    ITEM_ORDERS i
JOIN 
    PRODUCT p ON i.PRODUCT_ID = p.PRODUCT_ID
GROUP BY 
    p.PRODUCT_ID, p.NAME, p.CATEGORY
ORDER BY 
    TOTAL_REVENUE DESC;

GRANT SELECT ON PRODUCT_OVERVIEW TO accountant_role;
GRANT SELECT ON PRODUCT_OVERVIEW TO manager_role;

CREATE OR REPLACE VIEW customers_orders_overview AS
select c.customer_id, 
    (INITCAP(c.first_name) || ' ' || INITCAP(c.last_name)) as Customer, 
    o.order_date, 
    o.order_id as order_id, 
    p.product_id, 
    INITCAP(p.name) as Product_Name, 
    INITCAP(p.category) as Category, 
    '$' || p.selling_price as Product_Price, 
    i.units as Quantity, '$' || (i.selling_price*i.units) as Total from STORE_OWNER.orders o
    inner join STORE_OWNER.customer c on o.customer_id = c.customer_id
    inner join STORE_OWNER.item_orders i on o.order_id = i.order_id
    inner join STORE_OWNER.product p on i.product_id = p.product_id
    order by o.order_id; 
    
GRANT SELECT ON customers_orders_overview TO SALES_REP_ROLE;
GRANT SELECT ON customers_orders_overview  TO MANAGER_ROLE;


CREATE OR REPLACE PROCEDURE GET_WEEKLY_BEST_SELLER_REPORT(
    p_start_date DATE
) IS
    v_weekly_sales_cursor SYS_REFCURSOR;
    v_product_id NUMBER;
    v_product_name VARCHAR2(100);
    v_week_start_date DATE;
    v_total_units_sold NUMBER;
    v_total_revenue NUMBER;
BEGIN
    OPEN v_weekly_sales_cursor FOR
        WITH WeeklySales AS (
            SELECT 
                p.PRODUCT_ID, 
                p.NAME AS PRODUCT_NAME, 
                TRUNC(o.ORDER_DATE, 'WW') AS WEEK_START_DATE,
                SUM(i.UNITS) AS TOTAL_UNITS_SOLD, 
                SUM(i.UNITS * i.SELLING_PRICE) AS TOTAL_REVENUE,
                RANK() OVER (PARTITION BY TRUNC(o.ORDER_DATE, 'WW') ORDER BY SUM(i.UNITS) DESC) AS UNIT_RANK
            FROM 
                ITEM_ORDERS i
            JOIN 
                ORDERS o ON i.ORDER_ID = o.ORDER_ID
            JOIN 
                PRODUCT p ON i.PRODUCT_ID = p.PRODUCT_ID
            WHERE 
                o.ORDER_DATE >= p_start_date
            GROUP BY 
                p.PRODUCT_ID, p.NAME, TRUNC(o.ORDER_DATE, 'WW')
        )
        SELECT 
            PRODUCT_ID,
            PRODUCT_NAME,
            WEEK_START_DATE,
            TOTAL_UNITS_SOLD,
            TOTAL_REVENUE
        FROM 
            WeeklySales
        WHERE 
            UNIT_RANK = 1;

    LOOP
        FETCH v_weekly_sales_cursor INTO v_product_id, v_product_name, v_week_start_date, v_total_units_sold, v_total_revenue;
        EXIT WHEN v_weekly_sales_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Week Start Date: ' || TO_CHAR(v_week_start_date, 'YYYY-MM-DD') || 
                             ', Product ID: ' || v_product_id || 
                             ', Product Name: ' || v_product_name || 
                             ', Total Units Sold: ' || v_total_units_sold || 
                             ', Total Revenue: ' || v_total_revenue);
    END LOOP;

    CLOSE v_weekly_sales_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in GET_WEEKLY_BEST_SELLER_REPORT: ' || SQLERRM);
END GET_WEEKLY_BEST_SELLER_REPORT;
/


CREATE OR REPLACE PROCEDURE GET_MONTHLY_BEST_SELLER_REPORT(
    p_start_date DATE
) IS
    v_monthly_sales_cursor SYS_REFCURSOR;
    v_product_id NUMBER;
    v_product_name VARCHAR2(100);
    v_month_start_date DATE;
    v_total_units_sold NUMBER;
    v_total_revenue NUMBER;
BEGIN
    OPEN v_monthly_sales_cursor FOR
        WITH MonthlySales AS (
            SELECT 
                p.PRODUCT_ID, 
                p.NAME AS PRODUCT_NAME, 
                TRUNC(o.ORDER_DATE, 'MM') AS MONTH_START_DATE,
                SUM(i.UNITS) AS TOTAL_UNITS_SOLD, 
                SUM(i.UNITS * i.SELLING_PRICE) AS TOTAL_REVENUE,
                RANK() OVER (PARTITION BY TRUNC(o.ORDER_DATE, 'MM') ORDER BY SUM(i.UNITS) DESC) AS UNIT_RANK
            FROM 
                ITEM_ORDERS i
            JOIN 
                ORDERS o ON i.ORDER_ID = o.ORDER_ID
            JOIN 
                PRODUCT p ON i.PRODUCT_ID = p.PRODUCT_ID
            WHERE 
                o.ORDER_DATE >= p_start_date
            GROUP BY 
                p.PRODUCT_ID, p.NAME, TRUNC(o.ORDER_DATE, 'MM')
        )
        SELECT 
            PRODUCT_ID,
            PRODUCT_NAME,
            MONTH_START_DATE,
            TOTAL_UNITS_SOLD,
            TOTAL_REVENUE
        FROM 
            MonthlySales
        WHERE 
            UNIT_RANK = 1;

    LOOP
        FETCH v_monthly_sales_cursor INTO v_product_id, v_product_name, v_month_start_date, v_total_units_sold, v_total_revenue;
        EXIT WHEN v_monthly_sales_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Month Start Date: ' || TO_CHAR(v_month_start_date, 'YYYY-MM') || 
                             ' Product ID: ' || v_product_id || 
                             ' Product Name: ' || v_product_name || 
                             ' Total Units Sold: ' || v_total_units_sold || 
                             ' Total Revenue: ' || v_total_revenue);
    END LOOP;

    CLOSE v_monthly_sales_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in GET_MONTHLY_BEST_SELLER_REPORT: ' || SQLERRM);
END GET_MONTHLY_BEST_SELLER_REPORT;
/


CREATE OR REPLACE PROCEDURE GET_YEARLY_BEST_SELLER_REPORT(
    p_start_date DATE
) IS
    v_yearly_sales_cursor SYS_REFCURSOR;
    v_product_id NUMBER;
    v_product_name VARCHAR2(100);
    v_year_start_date DATE;
    v_total_units_sold NUMBER;
    v_total_revenue NUMBER;
BEGIN
    OPEN v_yearly_sales_cursor FOR
        WITH YearlySales AS (
            SELECT 
                p.PRODUCT_ID, 
                p.NAME AS PRODUCT_NAME, 
                TRUNC(o.ORDER_DATE, 'YYYY') AS YEAR_START_DATE,
                SUM(i.UNITS) AS TOTAL_UNITS_SOLD, 
                SUM(i.UNITS * i.SELLING_PRICE) AS TOTAL_REVENUE,
                RANK() OVER (PARTITION BY TRUNC(o.ORDER_DATE, 'YYYY') ORDER BY SUM(i.UNITS) DESC) AS UNIT_RANK
            FROM 
                ITEM_ORDERS i
            JOIN 
                ORDERS o ON i.ORDER_ID = o.ORDER_ID
            JOIN 
                PRODUCT p ON i.PRODUCT_ID = p.PRODUCT_ID
            WHERE 
                o.ORDER_DATE >= p_start_date
            GROUP BY 
                p.PRODUCT_ID, p.NAME, TRUNC(o.ORDER_DATE, 'YYYY')
        )
        SELECT 
            PRODUCT_ID,
            PRODUCT_NAME,
            YEAR_START_DATE,
            TOTAL_UNITS_SOLD,
            TOTAL_REVENUE
        FROM 
            YearlySales
        WHERE 
            UNIT_RANK = 1;

    LOOP
        FETCH v_yearly_sales_cursor INTO v_product_id, v_product_name, v_year_start_date, v_total_units_sold, v_total_revenue;
        EXIT WHEN v_yearly_sales_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Year Start Date: ' || TO_CHAR(v_year_start_date, 'YYYY') || 
                             ' Product ID: ' || v_product_id || 
                             ' Product Name: ' || v_product_name || 
                             ' Total Units Sold: ' || v_total_units_sold || 
                             ' Total Revenue: ' || v_total_revenue);
    END LOOP;

    CLOSE v_yearly_sales_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error in GET_YEARLY_BEST_SELLER_REPORT: ' || SQLERRM);
END GET_YEARLY_BEST_SELLER_REPORT;
/

CREATE OR REPLACE VIEW EMPLOYEE_PERFORMANCE AS
    SELECT 
        EMPLOYEE.EMPLOYEE_ID, 
        INITCAP(EMPLOYEE.FIRST_NAME) || ' ' || INITCAP(EMPLOYEE.LAST_NAME) AS EMPLOYEE_NAME, 
        LOWER(EMPLOYEE.EMAIL) as EMPLOYEE_EMAIL, 
        EMPLOYEE.WAGE,
        COUNT(DISTINCT ORDERS.ORDER_ID) AS TOTAL_ORDERS_TAKEN,
        NVL(SUM(ITEM_ORDERS.UNITS * ITEM_ORDERS.SELLING_PRICE), 0) AS TOTAL_REVENUE_GENERATED
    FROM 
        EMPLOYEE 
    LEFT OUTER JOIN 
        ORDERS ON ORDERS.EMPLOYEE_ID = EMPLOYEE.EMPLOYEE_ID
    LEFT OUTER JOIN 
        ITEM_ORDERS ON ORDERS.ORDER_ID = ITEM_ORDERS.ORDER_ID
    GROUP BY 
        EMPLOYEE.EMPLOYEE_ID, 
        EMPLOYEE.FIRST_NAME,
        EMPLOYEE.LAST_NAME,
        EMPLOYEE.EMAIL,
        EMPLOYEE.WAGE
    ORDER BY 
        TOTAL_REVENUE_GENERATED DESC
;

GRANT SELECT ON EMPLOYEE_PERFORMANCE TO manager_role;


CREATE OR REPLACE VIEW PRODUCT_PRICE_WISE_SALES AS 
SELECT
    p.product_id,
    INITCAP(p.name) AS product_name,
    INITCAP(p.category) AS PRODUCT_CATEGORY,
    ih.updated_price as during_price,
    COALESCE(SUM(io.units), 0) AS units_sold
FROM
    product_history ih
JOIN
    product p ON p.product_id = ih.product_id
LEFT OUTER JOIN
    item_orders io ON ih.product_id = io.product_id AND io.selling_price = ih.updated_price
GROUP BY
    p.product_id,
    p.name,
    p.category,
    ih.updated_price
ORDER BY
    p.product_id;

GRANT SELECT ON PRODUCT_PRICE_WISE_SALES TO manager_role;

CREATE OR REPLACE VIEW customers_orders_overview AS
select c.customer_id, 
    (INITCAP(c.first_name) || ' ' || INITCAP(c.last_name)) as Customer, 
    o.order_date, 
    o.order_id as order_id, 
    p.product_id, 
    INITCAP(p.name) as Product_Name, 
    INITCAP(p.category) as Category, 
    '$' || p.selling_price as Product_Price, 
    i.units as Quantity, 
    '$' || (i.selling_price*i.units) as Total 
        from STORE_OWNER.orders o
        inner join STORE_OWNER.customer c on o.customer_id = c.customer_id
        inner join STORE_OWNER.item_orders i on o.order_id = i.order_id
        inner join STORE_OWNER.product p on i.product_id = p.product_id
    order by o.order_id; 
    
GRANT SELECT ON customers_orders_overview TO SALES_REP_ROLE;
GRANT SELECT ON customers_orders_overview  TO MANAGER_ROLE;

CREATE OR REPLACE PACKAGE REPORTS_PACKAGE AS
    PROCEDURE GET_SALES_REP_QUARTERLY_SALES(p_year IN NUMBER);
    PROCEDURE GET_QUARTERLY_MOST_SOLD_PRODUCTS(p_year IN NUMBER);
    PROCEDURE GET_QUARTERLY_PURCHASES_REPORT(p_year IN NUMBER);
    PROCEDURE GET_QUARTERLY_SALES_REPORT(p_year IN NUMBER);
    PROCEDURE GET_TOP_CUSTOMERS_BY_QUARTER(p_year IN NUMBER);
END REPORTS_PACKAGE;
/

CREATE OR REPLACE PACKAGE BODY REPORTS_PACKAGE AS

    PROCEDURE GET_SALES_REP_QUARTERLY_SALES(p_year IN NUMBER)
    IS
        v_quarter NUMBER;
        v_sales_rep_name VARCHAR2(255);
        v_total_sales NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Sales Rep Quarterly Sales for the Year ' || p_year);
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
        FOR v_quarter IN 1..4 LOOP
            DBMS_OUTPUT.PUT_LINE('Quarter ' || v_quarter || ':');
    
            -- Now this query fetches data for all employees, not just 'Sales Rep'
            FOR rec IN (
                SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS sales_rep_name,
                       SUM(io.UNITS * io.SELLING_PRICE) AS total_sales
                FROM ORDERS o
                JOIN EMPLOYEE e ON o.EMPLOYEE_ID = e.EMPLOYEE_ID
                JOIN ITEM_ORDERS io ON o.ORDER_ID = io.ORDER_ID
                WHERE EXTRACT(YEAR FROM o.ORDER_DATE) = p_year
                    AND CEIL(EXTRACT(MONTH FROM o.ORDER_DATE) / 3) = v_quarter
                GROUP BY e.FIRST_NAME, e.LAST_NAME
                ORDER BY total_sales DESC
            ) LOOP
                DBMS_OUTPUT.PUT_LINE('Employee: ' || rec.sales_rep_name || ', Total Sales: $' || rec.total_sales);
            END LOOP;
    
            DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
        END LOOP;
    END GET_SALES_REP_QUARTERLY_SALES;

    PROCEDURE GET_QUARTERLY_MOST_SOLD_PRODUCTS(p_year IN NUMBER)
    IS
        v_quarter NUMBER;
        v_product_name VARCHAR2(255);
        v_total_units_sold NUMBER;
        v_rank NUMBER;
    
        CURSOR cur_products (c_year NUMBER, c_quarter NUMBER) IS
            SELECT p.NAME, total_units_sold, ROWNUM AS rank
            FROM (
                SELECT p.NAME, SUM(io.UNITS) AS total_units_sold
                FROM ORDERS o
                JOIN ITEM_ORDERS io ON o.ORDER_ID = io.ORDER_ID
                JOIN PRODUCT p ON io.PRODUCT_ID = p.PRODUCT_ID
                WHERE EXTRACT(YEAR FROM o.ORDER_DATE) = c_year
                AND CEIL(TO_NUMBER(TO_CHAR(o.ORDER_DATE, 'MM')) / 3) = c_quarter
                GROUP BY p.NAME
                ORDER BY SUM(io.UNITS) DESC
            ) p
            WHERE ROWNUM <= 3;
            
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Quarterly Top 3 Most Sold Products for the Year ' || p_year);
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
        FOR v_quarter IN 1..4 LOOP
            DBMS_OUTPUT.PUT_LINE('Quarter ' || v_quarter || ':');
    
            OPEN cur_products(p_year, v_quarter);
            LOOP
                FETCH cur_products INTO v_product_name, v_total_units_sold, v_rank;
                EXIT WHEN cur_products%NOTFOUND;
                DBMS_OUTPUT.PUT_LINE('Rank ' || v_rank || ' - Product: ' || v_product_name || ', Units Sold: ' || v_total_units_sold);
            END LOOP;
            CLOSE cur_products;
    
            DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
        END LOOP;
    END GET_QUARTERLY_MOST_SOLD_PRODUCTS;

    PROCEDURE GET_QUARTERLY_PURCHASES_REPORT(p_year IN NUMBER)
    IS
        v_quarter VARCHAR2(20);
        v_total_purchases NUMBER;
        v_start_date DATE;
        v_end_date DATE;
        v_report_cursor SYS_REFCURSOR;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Quarterly Purchases Report for the Year ' || p_year);
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
        -- Open the cursor for the query
        OPEN v_report_cursor FOR
            SELECT 
                CASE CEIL(TO_NUMBER(TO_CHAR(p.PURCHASE_DATE, 'MM')) / 3)
                    WHEN 1 THEN 'Q1 (Jan - Mar)'
                    WHEN 2 THEN 'Q2 (Apr - Jun)'
                    WHEN 3 THEN 'Q3 (Jul - Sep)'
                    WHEN 4 THEN 'Q4 (Oct - Dec)'
                END AS quarter,
                SUM(p.QUANTITY * p.BUYING_PRICE) AS total_purchases
            FROM Purchases p
            WHERE EXTRACT(YEAR FROM p.PURCHASE_DATE) = p_year
            GROUP BY CEIL(TO_NUMBER(TO_CHAR(p.PURCHASE_DATE, 'MM')) / 3)
            ORDER BY CEIL(TO_NUMBER(TO_CHAR(p.PURCHASE_DATE, 'MM')) / 3);
    
        -- Fetch and display the results
        LOOP
            FETCH v_report_cursor INTO v_quarter, v_total_purchases;
            EXIT WHEN v_report_cursor%NOTFOUND;
            
            DBMS_OUTPUT.PUT_LINE(v_quarter || ': ' || v_total_purchases || ' USD');
        END LOOP;
    
        -- Close the cursor
        CLOSE v_report_cursor;
        
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error in GET_QUARTERLY_PURCHASES_REPORT: ' || SQLERRM);
    END GET_QUARTERLY_PURCHASES_REPORT;

    PROCEDURE GET_QUARTERLY_SALES_REPORT(p_year IN NUMBER)
        IS
        v_quarter VARCHAR2(20);
        v_total_sales NUMBER;
        v_report_cursor SYS_REFCURSOR;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Quarterly Sales Report for the Year ' || p_year);
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
        -- Open the cursor for the query
        OPEN v_report_cursor FOR
            SELECT 
                CASE CEIL(TO_NUMBER(TO_CHAR(o.ORDER_DATE, 'MM')) / 3)
                    WHEN 1 THEN 'Q1 (Jan - Mar)'
                    WHEN 2 THEN 'Q2 (Apr - Jun)'
                    WHEN 3 THEN 'Q3 (Jul - Sep)'
                    WHEN 4 THEN 'Q4 (Oct - Dec)'
                END AS quarter,
                SUM(io.SELLING_PRICE * io.UNITS) AS total_sales
            FROM Orders o
            JOIN Item_Orders io ON o.ORDER_ID = io.ORDER_ID
            WHERE EXTRACT(YEAR FROM o.ORDER_DATE) = p_year
            GROUP BY CEIL(TO_NUMBER(TO_CHAR(o.ORDER_DATE, 'MM')) / 3)
            ORDER BY CEIL(TO_NUMBER(TO_CHAR(o.ORDER_DATE, 'MM')) / 3);
    
        -- Fetch and display the results
        LOOP
            FETCH v_report_cursor INTO v_quarter, v_total_sales;
            EXIT WHEN v_report_cursor%NOTFOUND;
            
            DBMS_OUTPUT.PUT_LINE(v_quarter || ': ' || v_total_sales || ' USD');
        END LOOP;
    
        -- Close the cursor
        CLOSE v_report_cursor;
        
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error in GET_QUARTERLY_SALES_REPORT: ' || SQLERRM);
    END GET_QUARTERLY_SALES_REPORT;

    PROCEDURE GET_TOP_CUSTOMERS_BY_QUARTER(p_year IN NUMBER)
    IS
        v_quarter VARCHAR2(20);
        v_customer_name VARCHAR2(255);
        v_total_sales NUMBER;
        v_rank NUMBER;
        
        CURSOR cur_customers (c_year NUMBER, c_quarter NUMBER) IS
            SELECT customer_name, total_sales, ROWNUM AS rank
            FROM (
                SELECT c.FIRST_NAME || ' ' || c.LAST_NAME AS customer_name,
                       SUM(io.SELLING_PRICE * io.UNITS) AS total_sales
                FROM ORDERS o
                JOIN ITEM_ORDERS io ON o.ORDER_ID = io.ORDER_ID
                JOIN CUSTOMER c ON o.CUSTOMER_ID = c.CUSTOMER_ID
                WHERE EXTRACT(YEAR FROM o.ORDER_DATE) = c_year
                AND CEIL(TO_NUMBER(TO_CHAR(o.ORDER_DATE, 'MM')) / 3) = c_quarter
                GROUP BY c.FIRST_NAME, c.LAST_NAME
                ORDER BY SUM(io.SELLING_PRICE * io.UNITS) DESC
            )
            WHERE ROWNUM <= 5;
            
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Top 5 Customers by Quarter for the Year ' || p_year);
        DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
    
        FOR v_quarter IN 1..4 LOOP
            DBMS_OUTPUT.PUT_LINE('Quarter ' || v_quarter || ':');
            
            OPEN cur_customers(p_year, v_quarter);
            LOOP
                FETCH cur_customers INTO v_customer_name, v_total_sales, v_rank;
                EXIT WHEN cur_customers%NOTFOUND;
                DBMS_OUTPUT.PUT_LINE('Rank ' || v_rank || ' - Customer: ' || v_customer_name || ', Total Sales: ' || v_total_sales || ' USD');
            END LOOP;
            CLOSE cur_customers;
            
            DBMS_OUTPUT.PUT_LINE('--------------------------------------------------');
        END LOOP;
    END GET_TOP_CUSTOMERS_BY_QUARTER;

END REPORTS_PACKAGE;
/

GRANT EXECUTE ON REPORTS_PACKAGE TO manager_role;
GRANT EXECUTE ON REPORTS_PACKAGE TO accountant_role;

/



